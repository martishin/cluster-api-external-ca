diff --git a/bootstrap/kubeadm/api/v1beta1/kubeadmconfig_types.go b/bootstrap/kubeadm/api/v1beta1/kubeadmconfig_types.go
index 9068936..88e3549 100644
--- a/bootstrap/kubeadm/api/v1beta1/kubeadmconfig_types.go
+++ b/bootstrap/kubeadm/api/v1beta1/kubeadmconfig_types.go
@@ -119,6 +119,12 @@ type KubeadmConfigSpec struct {
 	// Ignition contains Ignition specific configuration.
 	// +optional
 	Ignition *IgnitionSpec `json:"ignition,omitempty"`
+
+	// ExternalCA enables External CA mode of kubeadm:
+	// https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode
+	// by not requiring any CA keys to be provided beforehand.
+	// +optional
+	ExternalCA bool `json:"externalCA,omitempty"`
 }
 
 // Default defaults a KubeadmConfigSpec.
diff --git a/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigs.yaml b/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigs.yaml
index 2208256..e62bb8f 100644
--- a/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigs.yaml
+++ b/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigs.yaml
@@ -454,6 +454,12 @@ spec:
                       type: object
                     type: array
                 type: object
+              externalCA:
+                description: |-
+                  ExternalCA enables External CA mode of kubeadm:
+                  https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode
+                  by not requiring any CA keys to be provided beforehand.
+                type: boolean
               files:
                 description: Files specifies extra files to be passed to user_data
                   upon creation.
diff --git a/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigtemplates.yaml b/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigtemplates.yaml
index 9b6b709..6ce0b38 100644
--- a/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigtemplates.yaml
+++ b/bootstrap/kubeadm/config/crd/bases/bootstrap.cluster.x-k8s.io_kubeadmconfigtemplates.yaml
@@ -472,6 +472,12 @@ spec:
                               type: object
                             type: array
                         type: object
+                      externalCA:
+                        description: |-
+                          ExternalCA enables External CA mode of kubeadm:
+                          https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode
+                          by not requiring any CA keys to be provided beforehand.
+                        type: boolean
                       files:
                         description: Files specifies extra files to be passed to user_data
                           upon creation.
diff --git a/bootstrap/kubeadm/internal/controllers/kubeadmconfig_controller.go b/bootstrap/kubeadm/internal/controllers/kubeadmconfig_controller.go
index 926a00a..7b3d5e0 100644
--- a/bootstrap/kubeadm/internal/controllers/kubeadmconfig_controller.go
+++ b/bootstrap/kubeadm/internal/controllers/kubeadmconfig_controller.go
@@ -484,22 +484,36 @@ func (r *KubeadmConfigReconciler) handleClusterNotInitialized(ctx context.Contex
 	}
 
 	certificates := secret.NewCertificatesForInitialControlPlane(scope.Config.Spec.ClusterConfiguration)
+	if scope.Config.Spec.ExternalCA {
+		certificates = secret.NewCertificatesForInitialControlPlaneExternalCA(scope.Config.Spec.ClusterConfiguration)
+	}
 
 	// If the Cluster does not have a ControlPlane reference look up and generate the certificates.
 	// Otherwise rely on certificates generated by the ControlPlane controller.
 	// Note: A cluster does not have a ControlPlane reference when using standalone CP machines.
 	if scope.Cluster.Spec.ControlPlaneRef == nil {
-		err = certificates.LookupOrGenerateCached(
-			ctx,
-			r.SecretCachingClient,
-			r.Client,
-			util.ObjectKey(scope.Cluster),
-			*metav1.NewControllerRef(scope.Config, bootstrapv1.GroupVersion.WithKind("KubeadmConfig")))
+		if scope.Config.Spec.ExternalCA {
+			err = certificates.LookupOrErrorCached(
+				ctx,
+				r.SecretCachingClient,
+				r.Client,
+				util.ObjectKey(scope.Cluster))
+		} else {
+			err = certificates.LookupOrGenerateCached(
+				ctx,
+				r.SecretCachingClient,
+				r.Client,
+				util.ObjectKey(scope.Cluster),
+				*metav1.NewControllerRef(scope.Config, bootstrapv1.GroupVersion.WithKind("KubeadmConfig")))
+		}
 	} else {
 		err = certificates.LookupCached(ctx,
 			r.SecretCachingClient,
 			r.Client,
 			util.ObjectKey(scope.Cluster))
+		if err == nil && scope.Config.Spec.ExternalCA {
+			err = certificates.EnsureAllExist()
+		}
 	}
 	if err != nil {
 		conditions.MarkFalse(scope.Config, bootstrapv1.CertificatesAvailableCondition, bootstrapv1.CertificatesGenerationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
@@ -699,6 +713,9 @@ func (r *KubeadmConfigReconciler) joinControlplane(ctx context.Context, scope *S
 	}
 
 	certificates := secret.NewControlPlaneJoinCerts(scope.Config.Spec.ClusterConfiguration)
+	if scope.Config.Spec.ExternalCA {
+		certificates = secret.NewControlPlaneJoinCertsExternalCA(scope.Config.Spec.ClusterConfiguration)
+	}
 	err := certificates.LookupCached(
 		ctx,
 		r.SecretCachingClient,
diff --git a/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanes.yaml b/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanes.yaml
index 27ad7e0..f30446c 100644
--- a/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanes.yaml
+++ b/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanes.yaml
@@ -543,6 +543,12 @@ spec:
                           type: object
                         type: array
                     type: object
+                  externalCA:
+                    description: |-
+                      ExternalCA enables External CA mode of kubeadm:
+                      https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode
+                      by not requiring any CA keys to be provided beforehand.
+                    type: boolean
                   files:
                     description: Files specifies extra files to be passed to user_data
                       upon creation.
diff --git a/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanetemplates.yaml b/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanetemplates.yaml
index f8eca78..0ff026e 100644
--- a/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanetemplates.yaml
+++ b/controlplane/kubeadm/config/crd/bases/controlplane.cluster.x-k8s.io_kubeadmcontrolplanetemplates.yaml
@@ -481,6 +481,12 @@ spec:
                                   type: object
                                 type: array
                             type: object
+                          externalCA:
+                            description: |-
+                              ExternalCA enables External CA mode of kubeadm:
+                              https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode
+                              by not requiring any CA keys to be provided beforehand.
+                            type: boolean
                           files:
                             description: Files specifies extra files to be passed
                               to user_data upon creation.
diff --git a/controlplane/kubeadm/internal/controllers/controller.go b/controlplane/kubeadm/internal/controllers/controller.go
index e8b7309..923f58c 100644
--- a/controlplane/kubeadm/internal/controllers/controller.go
+++ b/controlplane/kubeadm/internal/controllers/controller.go
@@ -503,8 +503,17 @@ func (r *KubeadmControlPlaneReconciler) reconcileClusterCertificates(ctx context
 		config.ClusterConfiguration = &bootstrapv1.ClusterConfiguration{}
 	}
 	certificates := secret.NewCertificatesForInitialControlPlane(config.ClusterConfiguration)
+	if controlPlane.KCP.Spec.KubeadmConfigSpec.ExternalCA {
+		certificates = secret.NewCertificatesForInitialControlPlaneExternalCA(config.ClusterConfiguration)
+	}
 	controllerRef := metav1.NewControllerRef(controlPlane.KCP, controlplanev1.GroupVersion.WithKind(kubeadmControlPlaneKind))
-	if err := certificates.LookupOrGenerateCached(ctx, r.SecretCachingClient, r.Client, util.ObjectKey(controlPlane.Cluster), *controllerRef); err != nil {
+	var err error
+	if controlPlane.KCP.Spec.KubeadmConfigSpec.ExternalCA {
+		err = certificates.LookupOrErrorCached(ctx, r.SecretCachingClient, r.Client, util.ObjectKey(controlPlane.Cluster))
+	} else {
+		err = certificates.LookupOrGenerateCached(ctx, r.SecretCachingClient, r.Client, util.ObjectKey(controlPlane.Cluster), *controllerRef)
+	}
+	if err != nil {
 		log.Error(err, "Unable to lookup or create cluster certificates")
 		conditions.MarkFalse(controlPlane.KCP, controlplanev1.CertificatesAvailableCondition, controlplanev1.CertificatesGenerationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
 		return err
diff --git a/controlplane/kubeadm/internal/controllers/helpers.go b/controlplane/kubeadm/internal/controllers/helpers.go
index 98dcfd0..0445cb5 100644
--- a/controlplane/kubeadm/internal/controllers/helpers.go
+++ b/controlplane/kubeadm/internal/controllers/helpers.go
@@ -60,6 +60,10 @@ func (r *KubeadmControlPlaneReconciler) reconcileKubeconfig(ctx context.Context,
 	configSecret, err := secret.GetFromNamespacedName(ctx, r.SecretCachingClient, clusterName, secret.Kubeconfig)
 	switch {
 	case apierrors.IsNotFound(err):
+		if controlPlane.KCP.Spec.KubeadmConfigSpec.ExternalCA {
+			log.Info("Waiting for pre-created kubeconfig secret because externalCA is enabled", "Secret", secret.Name(clusterName.Name, secret.Kubeconfig))
+			return ctrl.Result{RequeueAfter: dependentCertRequeueAfter}, nil
+		}
 		createErr := kubeconfig.CreateSecretWithOwner(
 			ctx,
 			r.SecretCachingClient,
diff --git a/internal/apis/bootstrap/kubeadm/v1alpha3/zz_generated.conversion.go b/internal/apis/bootstrap/kubeadm/v1alpha3/zz_generated.conversion.go
index aa20da4..122797b 100644
--- a/internal/apis/bootstrap/kubeadm/v1alpha3/zz_generated.conversion.go
+++ b/internal/apis/bootstrap/kubeadm/v1alpha3/zz_generated.conversion.go
@@ -535,6 +535,7 @@ func autoConvert_v1beta1_KubeadmConfigSpec_To_v1alpha3_KubeadmConfigSpec(in *v1b
 	out.Verbosity = (*int32)(unsafe.Pointer(in.Verbosity))
 	out.UseExperimentalRetryJoin = in.UseExperimentalRetryJoin
 	// WARNING: in.Ignition requires manual conversion: does not exist in peer-type
+	// WARNING: in.ExternalCA requires manual conversion: does not exist in peer-type
 	return nil
 }
 
diff --git a/internal/apis/bootstrap/kubeadm/v1alpha4/zz_generated.conversion.go b/internal/apis/bootstrap/kubeadm/v1alpha4/zz_generated.conversion.go
index 1e79a52..25672e7 100644
--- a/internal/apis/bootstrap/kubeadm/v1alpha4/zz_generated.conversion.go
+++ b/internal/apis/bootstrap/kubeadm/v1alpha4/zz_generated.conversion.go
@@ -1228,6 +1228,7 @@ func autoConvert_v1beta1_KubeadmConfigSpec_To_v1alpha4_KubeadmConfigSpec(in *v1b
 	out.Verbosity = (*int32)(unsafe.Pointer(in.Verbosity))
 	out.UseExperimentalRetryJoin = in.UseExperimentalRetryJoin
 	// WARNING: in.Ignition requires manual conversion: does not exist in peer-type
+	// WARNING: in.ExternalCA requires manual conversion: does not exist in peer-type
 	return nil
 }
 
diff --git a/test/infrastructure/docker/examples/simple-cluster-with-external-ca.yaml b/test/infrastructure/docker/examples/simple-cluster-with-external-ca.yaml
new file mode 100644
index 0000000..4948c31
--- /dev/null
+++ b/test/infrastructure/docker/examples/simple-cluster-with-external-ca.yaml
@@ -0,0 +1,112 @@
+# Creates a cluster with one control-plane node and one worker node.
+apiVersion: cluster.x-k8s.io/v1beta1
+kind: Cluster
+metadata:
+  name: my-cluster
+  namespace: default
+spec:
+  clusterNetwork:
+    services:
+      cidrBlocks: ["10.96.0.0/12"]
+    pods:
+      cidrBlocks: ["192.168.0.0/16"]
+    serviceDomain: cluster.local
+  controlPlaneRef:
+    apiVersion: controlplane.cluster.x-k8s.io/v1beta1
+    kind: KubeadmControlPlane
+    name: controlplane
+    namespace: default
+  infrastructureRef:
+    apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
+    kind: DockerCluster
+    name: my-cluster
+    namespace: default
+---
+apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
+kind: DockerCluster
+metadata:
+  name: my-cluster
+  namespace: default
+---
+apiVersion: controlplane.cluster.x-k8s.io/v1beta1
+kind: KubeadmControlPlane
+metadata:
+  name: controlplane
+  namespace: default
+spec:
+  replicas: 1
+  version: v1.29.2
+  machineTemplate:
+    infrastructureRef:
+      apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
+      kind: DockerMachineTemplate
+      name: controlplane
+      namespace: default
+  kubeadmConfigSpec:
+    externalCA: true
+    initConfiguration:
+      nodeRegistration:
+        kubeletExtraArgs:
+          eviction-hard: nodefs.available<0%,nodefs.inodesFree<0%,imagefs.available<0%
+    joinConfiguration:
+      nodeRegistration:
+        kubeletExtraArgs:
+          eviction-hard: nodefs.available<0%,nodefs.inodesFree<0%,imagefs.available<0%
+---
+apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
+kind: DockerMachineTemplate
+metadata:
+  name: controlplane
+  namespace: default
+spec:
+  template:
+    spec: {}
+---
+apiVersion: cluster.x-k8s.io/v1beta1
+kind: MachineDeployment
+metadata:
+  name: worker-md-0
+  namespace: default
+spec:
+  clusterName: my-cluster
+  replicas: 1
+  selector:
+    matchLabels:
+      cluster.x-k8s.io/cluster-name: my-cluster
+  template:
+    spec:
+      clusterName: my-cluster
+      version: v1.29.2
+      bootstrap:
+        configRef:
+          apiVersion: bootstrap.cluster.x-k8s.io/v1beta1
+          kind: KubeadmConfigTemplate
+          name: worker
+          namespace: default
+      infrastructureRef:
+        apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
+        kind: DockerMachineTemplate
+        name: worker
+        namespace: default
+---
+apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
+kind: DockerMachineTemplate
+metadata:
+  name: worker
+  namespace: default
+spec:
+  template:
+    spec: {}
+---
+apiVersion: bootstrap.cluster.x-k8s.io/v1beta1
+kind: KubeadmConfigTemplate
+metadata:
+  name: worker
+  namespace: default
+spec:
+  template:
+    spec:
+      joinConfiguration:
+        nodeRegistration:
+          kubeletExtraArgs:
+            eviction-hard: nodefs.available<0%,nodefs.inodesFree<0%,imagefs.available<0%
diff --git a/util/kubeconfig/kubeconfig.go b/util/kubeconfig/kubeconfig.go
index 3c5338f..c96a24b 100644
--- a/util/kubeconfig/kubeconfig.go
+++ b/util/kubeconfig/kubeconfig.go
@@ -219,9 +219,9 @@ func generateKubeconfig(ctx context.Context, c client.Client, clusterName client
 
 	key, err := certs.DecodePrivateKeyPEM(clusterCA.Data[secret.TLSKeyDataName])
 	if err != nil {
-		return nil, errors.Wrap(err, "failed to decode private key")
+		return nil, ErrDependentCertificateNotFound
 	} else if key == nil {
-		return nil, errors.New("CA private key not found")
+		return nil, ErrDependentCertificateNotFound
 	}
 
 	cfg, err := New(clusterName.Name, endpoint, cert, key)
diff --git a/util/secret/certificates.go b/util/secret/certificates.go
index b1d553c..ba787b7 100644
--- a/util/secret/certificates.go
+++ b/util/secret/certificates.go
@@ -114,6 +114,54 @@ func NewCertificatesForInitialControlPlane(config *bootstrapv1.ClusterConfigurat
 	return certificates
 }
 
+// NewCertificatesForInitialControlPlaneExternalCA returns a list of certificates configured for a control plane,
+// not requiring CA private keys.
+func NewCertificatesForInitialControlPlaneExternalCA(config *bootstrapv1.ClusterConfiguration) Certificates {
+	certificatesDir := DefaultCertificatesDir
+	if config != nil && config.CertificatesDir != "" {
+		certificatesDir = config.CertificatesDir
+	}
+
+	certificates := Certificates{
+		&Certificate{
+			Purpose:  ClusterCA,
+			CertFile: path.Join(certificatesDir, "ca.crt"),
+		},
+		&Certificate{
+			Purpose:  ServiceAccount,
+			CertFile: path.Join(certificatesDir, "sa.pub"),
+			KeyFile:  path.Join(certificatesDir, "sa.key"),
+		},
+		&Certificate{
+			Purpose:  FrontProxyCA,
+			CertFile: path.Join(certificatesDir, "front-proxy-ca.crt"),
+		},
+	}
+
+	etcdCert := &Certificate{
+		Purpose:  EtcdCA,
+		CertFile: path.Join(certificatesDir, "etcd", "ca.crt"),
+	}
+
+	if config != nil && config.Etcd.External != nil {
+		etcdCert = &Certificate{
+			Purpose:  EtcdCA,
+			CertFile: config.Etcd.External.CAFile,
+			External: true,
+		}
+		apiserverEtcdClientCert := &Certificate{
+			Purpose:  APIServerEtcdClient,
+			CertFile: config.Etcd.External.CertFile,
+			KeyFile:  config.Etcd.External.KeyFile,
+			External: true,
+		}
+		certificates = append(certificates, apiserverEtcdClientCert)
+	}
+
+	certificates = append(certificates, etcdCert)
+	return certificates
+}
+
 // NewControlPlaneJoinCerts gets any certs that exist and writes them to disk.
 func NewControlPlaneJoinCerts(config *bootstrapv1.ClusterConfiguration) Certificates {
 	certificatesDir := DefaultCertificatesDir
@@ -164,6 +212,53 @@ func NewControlPlaneJoinCerts(config *bootstrapv1.ClusterConfiguration) Certific
 	return certificates
 }
 
+// NewControlPlaneJoinCertsExternalCA gets any certs that exist, not requiring CA private keys.
+func NewControlPlaneJoinCertsExternalCA(config *bootstrapv1.ClusterConfiguration) Certificates {
+	certificatesDir := DefaultCertificatesDir
+	if config != nil && config.CertificatesDir != "" {
+		certificatesDir = config.CertificatesDir
+	}
+
+	certificates := Certificates{
+		&Certificate{
+			Purpose:  ClusterCA,
+			CertFile: path.Join(certificatesDir, "ca.crt"),
+		},
+		&Certificate{
+			Purpose:  ServiceAccount,
+			CertFile: path.Join(certificatesDir, "sa.pub"),
+			KeyFile:  path.Join(certificatesDir, "sa.key"),
+		},
+		&Certificate{
+			Purpose:  FrontProxyCA,
+			CertFile: path.Join(certificatesDir, "front-proxy-ca.crt"),
+		},
+	}
+
+	etcdCert := &Certificate{
+		Purpose:  EtcdCA,
+		CertFile: path.Join(certificatesDir, "etcd", "ca.crt"),
+	}
+
+	if config != nil && config.Etcd.External != nil {
+		etcdCert = &Certificate{
+			Purpose:  EtcdCA,
+			CertFile: config.Etcd.External.CAFile,
+			External: true,
+		}
+		apiserverEtcdClientCert := &Certificate{
+			Purpose:  APIServerEtcdClient,
+			CertFile: config.Etcd.External.CertFile,
+			KeyFile:  config.Etcd.External.KeyFile,
+			External: true,
+		}
+		certificates = append(certificates, apiserverEtcdClientCert)
+	}
+
+	certificates = append(certificates, etcdCert)
+	return certificates
+}
+
 // NewCertificatesForWorker return an initialized but empty set of CA certificates needed to bootstrap a cluster.
 func NewCertificatesForWorker(caCertPath string) Certificates {
 	if caCertPath == "" {
@@ -256,7 +351,7 @@ func (c Certificates) EnsureAllExist() error {
 		if len(certificate.KeyPair.Cert) == 0 {
 			return errors.Wrapf(ErrMissingCrt, "for certificate: %s", certificate.Purpose)
 		}
-		if !certificate.External {
+		if !certificate.External && certificate.KeyFile != "" {
 			if len(certificate.KeyPair.Key) == 0 {
 				return errors.Wrapf(ErrMissingKey, "for certificate: %s", certificate.Purpose)
 			}
@@ -316,6 +411,16 @@ func (c Certificates) LookupOrGenerateCached(ctx context.Context, secretCachingC
 	return c.SaveGenerated(ctx, ctrlclient, clusterName, owner)
 }
 
+// LookupOrErrorCached looks up certificates and returns an error if any expected cert/key is missing.
+// During lookup we first try to lookup the certificate secret via the secretCachingClient. If we get a NotFound error
+// we fall back to the regular uncached client.
+func (c Certificates) LookupOrErrorCached(ctx context.Context, secretCachingClient, ctrlclient client.Client, clusterName client.ObjectKey) error {
+	if err := c.LookupCached(ctx, secretCachingClient, ctrlclient, clusterName); err != nil {
+		return err
+	}
+	return c.EnsureAllExist()
+}
+
 // Certificate represents a single certificate CA.
 type Certificate struct {
 	Generated         bool
